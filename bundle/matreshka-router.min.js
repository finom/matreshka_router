(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _router = __webpack_require__(1);
	
	var _router2 = _interopRequireDefault(_router);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function initRouter(obj, route, type) {
	    _router2.default[type || 'hash'].subscribe(obj, route);
	    return obj;
	}
	
	/* istanbul ignore if */
	/* globals Matreshka */
	
	if (typeof Matreshka === 'function') {
	    Matreshka.Router = _router2.default;
	    Matreshka.initRouter = initRouter;
	}
	
	module.exports = initRouter;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _calc = __webpack_require__(2);
	
	var _calc2 = _interopRequireDefault(_calc);
	
	var _on = __webpack_require__(42);
	
	var _on2 = _interopRequireDefault(_on);
	
	var _ondebounce = __webpack_require__(44);
	
	var _ondebounce2 = _interopRequireDefault(_ondebounce);
	
	var _trigger = __webpack_require__(45);
	
	var _trigger2 = _interopRequireDefault(_trigger);
	
	var _set = __webpack_require__(13);
	
	var _set2 = _interopRequireDefault(_set);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function handleHashChange(router) {
	    (0, _set2.default)(router, 'hashPath', window.location.hash, {
	        hashEvent: true
	    });
	}
	
	function handlePopStateChange(router) {
	    (0, _set2.default)(router, 'path', window.location.pathname, {
	        popEvent: true
	    });
	}
	
	var Router = function () {
	    function Router(type) {
	        _classCallCheck(this, Router);
	
	        this.parts = [];
	        this.path = '/';
	        this.hashPath = '!#/';
	
	        // singletone pattern for history and hash router
	        /* istanbul ignore if */
	        if (type in Router) {
	            return Router[type];
	        }
	
	        this.type = type;
	
	        return this;
	    }
	
	    _createClass(Router, [{
	        key: 'init',
	        value: function init() {
	            var _this = this;
	
	            if (this.initialized) {
	                return this;
	            }
	
	            var type = this.type;
	
	
	            (0, _calc2.default)(this, {
	                parts: {
	                    source: 'path',
	                    handler: function handler(path) {
	                        var fixed = path.replace(/\/\//g, '/').replace(/^\/|\/$/g, '');
	
	                        return fixed ? fixed.split('/') : [];
	                    }
	                },
	                path: {
	                    source: 'parts',
	                    handler: function handler(parts) {
	                        var nonEmptyParts = [];
	
	                        for (var i = 0; i < parts.length; i++) {
	                            if (parts[i]) {
	                                nonEmptyParts.push(parts[i]);
	                            } else {
	                                break;
	                            }
	                        }
	
	                        return nonEmptyParts.length ? '/' + nonEmptyParts.join('/') + '/' : '/';
	                    }
	                }
	            }, { debounceCalc: false });
	
	            (0, _calc2.default)(this, {
	                hashPath: {
	                    source: 'path',
	                    handler: function handler(path) {
	                        return path && path !== '/' ? '#!' + path : '';
	                    }
	                },
	                path: {
	                    source: 'hashPath',
	                    handler: function handler(hashPath) {
	                        return hashPath ? hashPath.replace(/^#!/, '') : '';
	                    }
	                }
	            }, { debounceCalc: false });
	
	            (0, _on2.default)(this, 'change:parts', function (evt) {
	                var value = evt.value;
	                var previousValue = evt.previousValue;
	
	                var equals = value.length === previousValue.length;
	
	                if (equals) {
	                    for (var i = 0; i < value.length; i++) {
	                        if (value[i] !== previousValue[i]) {
	                            equals = false;
	                            break;
	                        }
	                    }
	                }
	
	                if (!equals) {
	                    (0, _trigger2.default)(_this, 'pathchange');
	                }
	            });
	
	            if (typeof window !== 'undefined') {
	                (function () {
	                    var _window = window;
	                    var history = _window.history;
	                    var location = _window.location;
	
	
	                    if (type === 'hash') {
	                        handleHashChange(_this);
	
	                        window.addEventListener('hashchange', function () {
	                            return handleHashChange(_this);
	                        });
	
	                        (0, _ondebounce2.default)(_this, 'change:hashPath', function (evt) {
	                            if (!evt || !evt.hashEvent) {
	                                location.hash = _this.hashPath;
	                            }
	                        }, true);
	                    } else if (type === 'history') {
	                        handlePopStateChange(_this);
	
	                        window.addEventListener('popstate', function (evt) {
	                            if (evt.state && evt.state.validPush) {
	                                handlePopStateChange(_this);
	                            }
	                        });
	
	                        (0, _ondebounce2.default)(_this, 'change:path', function (evt) {
	                            if (!evt || !evt.popEvent) {
	                                history.pushState({
	                                    validPush: true
	                                }, '', _this.path + location.hash);
	                            }
	                        }, true);
	                    }
	                })();
	            }
	
	            this.initialized = true;
	
	            return this;
	        }
	    }, {
	        key: 'subscribe',
	        value: function subscribe(obj, route) {
	            var _this2 = this;
	
	            var keys = route.replace(/\/\//g, '/').replace(/^\/|\/$/g, '').split('/');
	            var changeEvents = [];
	            var filteredKeys = keys.filter(function (key) {
	                return key !== '*';
	            });
	            var parts = [];
	
	            this.init();
	
	            for (var i = 0; i < filteredKeys.length; i++) {
	                var key = filteredKeys[i];
	                changeEvents.push('change:' + key);
	            }
	
	            (0, _on2.default)(obj, changeEvents, function (evt) {
	                if (evt && evt.routeSilent) {
	                    return;
	                }
	
	                var values = [];
	
	                for (var _i = 0; _i < keys.length; _i++) {
	                    var value = keys[_i] === '*' ? _this2.parts[_i] : obj[keys[_i]];
	
	                    if (value) {
	                        values.push(value);
	                    } else {
	                        break;
	                    }
	                }
	
	                _this2.parts = values;
	            });
	
	            for (var _i2 = 0; _i2 < keys.length; _i2++) {
	                parts.push(obj[keys[_i2]] === '*' ? this.parts[_i2] : obj[keys[_i2]] || this.parts[_i2]);
	            }
	
	            for (var _i3 = 0; _i3 < keys.length; _i3++) {
	                if (typeof obj[keys[_i3]] === 'undefined' && this.parts[_i3] && keys[_i3] !== '*') {
	                    (0, _set2.default)(obj, keys[_i3], this.parts[_i3], {
	                        routeSilent: true
	                    });
	                }
	            }
	
	            (0, _on2.default)(this, 'pathchange', function () {
	                for (var _i4 = 0; _i4 < keys.length; _i4++) {
	                    if (keys[_i4] !== '*') {
	                        (0, _set2.default)(obj, keys[_i4], _this2.parts[_i4] || null, {
	                            routeSilent: true
	                        });
	                    }
	                }
	            });
	
	            this.parts = parts;
	
	            return this;
	        }
	    }]);
	
	    return Router;
	}();
	
	Router.history = new Router('history');
	Router.hash = new Router('hash');
	
	module.exports = Router;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var initMK = __webpack_require__(3);
	
	var checkObjectType = __webpack_require__(5);
	
	var matreshkaError = __webpack_require__(6);
	
	var debounce = __webpack_require__(7);
	
	var addSource = __webpack_require__(9);
	
	var createCalcHandler = __webpack_require__(40);
	
	var defineProp = __webpack_require__(12);
	
	// defines a property which is dependend on other properties
	module.exports = calc;
	function calc(object, target, sources, givenHandler, eventOptions) {
	    if (_typeof(this) === 'object' && this.isMatreshka) {
	        // when context is Matreshka instance, use this as an object and shift other args
	        /* eslint-disable no-param-reassign */
	        eventOptions = givenHandler;
	        givenHandler = sources;
	        sources = target;
	        target = object;
	        object = this;
	        /* eslint-enable no-param-reassign */
	    } else {
	        // throw error when object type is wrong
	        checkObjectType(object, 'calc');
	    }
	
	    if (target instanceof Object) {
	        for (var _target = target, _keys5 = Object.keys(_target), _i5 = 0, itemTarget, _ref, _l5 = _keys5.length; (itemTarget = _keys5[_i5], _ref = _target[itemTarget]), _i5 < _l5; _i5++) {
	            var itemSource = _ref.source;
	            var itemHandler = _ref.handler;
	            var itemEventOptions = _ref.event;
	
	            var commonEventOptions = sources;
	            var mergedEventOptions = {};
	
	            if (commonEventOptions) {
	                var _result = mergedEventOptions;
	                // extend event object by "global" event
	
	                for (var _source2 = commonEventOptions, _keys2 = Object.keys(_source2), _l2 = _keys2.length, _i2 = 0, _key2; _i2 < _l2; _i2++) {
	                    _key2 = _keys2[_i2];
	                    _result[_key2] = _source2[_key2];
	                }
	            }
	
	            if (itemEventOptions) {
	                var _result2 = mergedEventOptions;
	                // extend event object by "local" event ("event" key of an object)
	
	                for (var _source4 = itemEventOptions, _keys4 = Object.keys(_source4), _l4 = _keys4.length, _i4 = 0, _key4; _i4 < _l4; _i4++) {
	                    _key4 = _keys4[_i4];
	                    _result2[_key4] = _source4[_key4];
	                }
	            }
	
	            calc(object, itemTarget, itemSource, itemHandler, mergedEventOptions);
	        }
	        /*
	         * accept an object
	         * this.calc({target: { source, handler, event } }, commonEventOptions);
	         */
	
	        return object;
	    }
	
	    if (typeof target !== 'string') {
	        throw matreshkaError('calc:target_type', { target: target });
	    }
	
	    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign
	    var def = initMK(object);
	    var _eventOptions = eventOptions;
	    var _eventOptions$setOnIn = _eventOptions.setOnInit;
	    var setOnInit = _eventOptions$setOnIn === undefined ? true : _eventOptions$setOnIn;
	    var _eventOptions$debounc = _eventOptions.debounceCalcOnInit;
	    var debounceCalcOnInit = _eventOptions$debounc === undefined ? false : _eventOptions$debounc;
	    var _eventOptions$debounc2 = _eventOptions.debounceCalc;
	    var debounceCalc = _eventOptions$debounc2 === undefined ? true : _eventOptions$debounc2;
	    var _eventOptions$isTarge = _eventOptions.isTargetPropertyHidden;
	    var isTargetPropertyHidden = _eventOptions$isTarge === undefined ? false : _eventOptions$isTarge;
	
	    var defaultHandler = function defaultHandler(value) {
	        return value;
	    };
	    var handler = givenHandler || defaultHandler;
	    var allSources = [];
	    var syncCalcHandler = createCalcHandler({
	        object: object,
	        eventOptions: eventOptions,
	        allSources: allSources,
	        target: target,
	        def: def,
	        handler: handler
	    });
	
	    var debouncedCalcHandler = void 0;
	    var calcHandler = void 0;
	
	    if (debounceCalcOnInit || debounceCalc) {
	        debouncedCalcHandler = debounce(syncCalcHandler);
	    }
	
	    defineProp(object, target, isTargetPropertyHidden);
	
	    if (!(sources instanceof Array)) {
	        sources = [sources]; // eslint-disable-line no-param-reassign
	    }
	
	    if (debounceCalc) {
	        calcHandler = debouncedCalcHandler;
	    } else {
	        calcHandler = syncCalcHandler;
	    }
	
	    for (var _target3 = sources, _index2 = 0, source, _l7 = _target3.length; source = _target3[_index2], _index2 < _l7; _index2++) {
	        if (typeof source === 'string') {
	            // source object is current object
	            addSource({
	                calcHandler: calcHandler,
	                allSources: allSources,
	                sourceKey: source,
	                sourceObject: object,
	                eventOptions: eventOptions
	            });
	        } else {
	            (function () {
	                // source object is external object
	                if (!source || (typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
	                    throw matreshkaError('calc:source_type', { source: source });
	                }
	
	                var sourceKey = source.key;
	                var sourceObject = source.object;
	                if (sourceKey instanceof Array) {
	                    for (var _target2 = sourceKey, _index = 0, sourceKeyItem, _l6 = _target2.length; sourceKeyItem = _target2[_index], _index < _l6; _index++) {
	                        addSource({
	                            calcHandler: calcHandler,
	                            allSources: allSources,
	                            sourceKey: sourceKeyItem,
	                            sourceObject: sourceObject,
	                            eventOptions: eventOptions
	                        });
	                    }
	                    // many keys are passed
	                } else {
	                    // one key is passed
	                    addSource({
	                        calcHandler: calcHandler,
	                        allSources: allSources,
	                        sourceKey: sourceKey,
	                        sourceObject: sourceObject,
	                        eventOptions: eventOptions
	                    });
	                }
	            })();
	        }
	    }
	
	    if (setOnInit) {
	        if (debounceCalcOnInit) {
	            debouncedCalcHandler();
	        } else {
	            syncCalcHandler();
	        }
	    }
	
	    return object;
	}

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var defs = __webpack_require__(4);
	
	var objectId = 0;
	
	// this is common function which associates an object with its Matreshka definition
	module.exports = initMK;
	function initMK(object) {
	    var def = defs.get(object);
	    if (!def) {
	        def = {
	            // a property name of "events" object is an event name
	            // and a value is an array of event handlers
	            events: {
	                /* example: {
	                    callback: function,
	                    ctx: object,
	                    context: object2,
	                    name: "example",
	                    info: { ...extra data for an event... }
	                } */
	            },
	            // "props" contains special information about properties (getters, setters etc)
	            props: {
	                /* example: {
	                    value: object[key],
	                    mediator: null,
	                    bindings: [{
	                        node,
	                        binder,
	                        nodeHandler,
	                        objectHandler,
	                        ...other required info
	                    }]
	                }*/
	            },
	            id: objectId++
	        };
	
	        defs.set(object, def);
	
	        if (object._afterInit) {
	            object._afterInit(def);
	        }
	    }
	
	    return def;
	}

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';
	
	function PseudoMap() {}
	
	// PseudoMap simulates WeakMap behavior with O(1) search complexity
	// it's needed to support @IE9 and @IE10
	var _result = PseudoMap.prototype;
	
	for (var _source2 = {
	    get: function get(obj) {
	        return obj.matreshkaData;
	    },
	    set: function set(obj, data) {
	        Object.defineProperty(obj, 'matreshkaData', {
	            value: data,
	            enumerable: false,
	            writable: false,
	            configurable: false
	        });
	    },
	    has: function has(obj) {
	        return ('matreshkaData' in obj);
	    }
	}, _keys2 = Object.keys(_source2), _l2 = _keys2.length, _i2 = 0, _key2; _i2 < _l2; _i2++) {
	    _key2 = _keys2[_i2];
	    _result[_key2] = _source2[_key2];
	}
	
	module.exports = typeof WeakMap === 'undefined' ? new PseudoMap() : new WeakMap();

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var matreshkaError = __webpack_require__(6);
	
	// checks type of a variable and throws an error if its type is not an object
	module.exports = checkObjectType;
	function checkObjectType(object, method) {
	    var typeofObject = object === null ? 'null' : typeof object === 'undefined' ? 'undefined' : _typeof(object);
	
	    if (typeofObject !== 'object' && typeofObject !== 'function') {
	        throw matreshkaError('common:object_type', {
	            object: object,
	            method: method
	        });
	    }
	}

/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';
	
	/* eslint-disable prefer-template, max-len */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var bindingErrorPrefix = 'Binding error:';
	var calcErrorPrefix = 'Calc error:';
	var eventsErrorPrefix = 'Events error:';
	var arrayErrorPrefix = 'Matreshka.Array error:';
	
	var getType = function getType(variable) {
	    if (variable === null) {
	        return 'null';
	    }
	
	    return typeof variable === 'undefined' ? 'undefined' : _typeof(variable);
	};
	var getTypeError = function getTypeError(variable, variableName, expectedType) {
	    return variableName + ' must have type "' + expectedType + '" but got "' + getType(variable) + '" instead.';
	};
	
	var errors = {
	    'common:object_type': function commonObject_type(_ref) {
	        var object = _ref.object;
	        var method = _ref.method;
	        return 'Error in ' + method + ':' + getTypeError(object, 'object', 'object');
	    },
	    'common:call_class': function commonCall_class() {
	        return 'Cannot call a class as a function';
	    },
	    'common:use_magic_props': function commonUse_magic_props() {
	        return '"sandbox" key (for all objects) and "container" key (for Matreshka.Array instances)' + ' are reserved for service use and cannot be used as usual properties';
	    },
	
	    'binding:node_missing': function bindingNode_missing(_ref2) {
	        var key = _ref2.key;
	        var node = _ref2.node;
	
	        var selectorInfo = typeof node === 'string' ? ' (given selector is "' + node + '")' : '';
	        return bindingErrorPrefix + ' node is missing for key "' + key + '"' + selectorInfo + '.';
	    },
	    'binding:falsy_key': function bindingFalsy_key() {
	        return bindingErrorPrefix + ' "key" arg cannot be falsy';
	    },
	    'binding:instance_nodes_missing': function bindingInstance_nodes_missing(_ref3) {
	        var $nodes = _ref3.$nodes;
	
	        var missing = !$nodes ? '$nodes' : 'nodes';
	        return bindingErrorPrefix + ' "' + missing + '" property of Matreshka instance is missing.' + ' It must be an object and must not be reassigned.';
	    },
	    'binding:magic_props_nodes_length': function bindingMagic_props_nodes_length() {
	        return bindingErrorPrefix + ' "sandbox" key (for all objects) and "container" key' + ' (for Matreshka.Array instances) cannot have more than one bound node';
	    },
	
	    'calc:target_type': function calcTarget_type(_ref4) {
	        var target = _ref4.target;
	        return calcErrorPrefix + ' ' + getTypeError(target, 'target key', 'string');
	    },
	    'calc:source_key_type': function calcSource_key_type(_ref5) {
	        var sourceKey = _ref5.sourceKey;
	        return calcErrorPrefix + ' ' + getTypeError(sourceKey, 'source key', 'string');
	    },
	    'calc:source_object_type': function calcSource_object_type(_ref6) {
	        var sourceObject = _ref6.sourceObject;
	        return calcErrorPrefix + ' ' + getTypeError(sourceObject, 'source object', 'object');
	    },
	    'calc:source_type': function calcSource_type(_ref7) {
	        var source = _ref7.source;
	        return calcErrorPrefix + ' ' + getTypeError(source, 'source', 'object');
	    },
	
	    'array:model_type': function arrayModel_type(_ref8) {
	        var Model = _ref8.Model;
	        return arrayErrorPrefix + ' ' + getTypeError(Model, 'Model', 'function');
	    },
	    'array:add_render_twice': function arrayAdd_render_twice() {
	        return arrayErrorPrefix + ' one rendered object was inserted twice.';
	    },
	    'array:rendered_number_nodes': function arrayRendered_number_nodes(_ref9) {
	        var length = _ref9.length;
	        return arrayErrorPrefix + ' renderer returned ' + length + ' nodes instead of one.' + (' ' + (length > 0 ? 'To fix this wrap these nodes by single node.' : ''));
	    },
	    'array:renderer_node_missing': function arrayRenderer_node_missing(_ref10) {
	        var selector = _ref10.selector;
	        return arrayErrorPrefix + ' renderer node is missing (given selector is "' + selector + '")';
	    },
	
	    'pull:to_remove_type': function pullTo_remove_type(_ref11) {
	        var toRemove = _ref11.toRemove;
	        return 'Error in pull: ' + getTypeError(toRemove, 'toRemove', 'number');
	    },
	
	    'restore:no_nodes': function restoreNo_nodes() {
	        return arrayErrorPrefix + ' cannot find any container to restore an instance using "restore" method';
	    },
	
	    'trigger:names_type': function triggerNames_type(_ref12) {
	        var names = _ref12.names;
	        return eventsErrorPrefix + ' ' + getTypeError(names, 'event name', 'string');
	    },
	
	    'on:names_type': function onNames_type(_ref13) {
	        var names = _ref13.names;
	        return errors['trigger:names_type']({ names: names });
	    },
	
	    'removedatakeys:key_type': function removedatakeysKey_type(_ref14) {
	        var key = _ref14.key;
	        return 'Error in removeDataKeys: ' + getTypeError(key, 'key', 'string');
	    },
	
	    'adddatakeys:key_type': function adddatakeysKey_type(_ref15) {
	        var key = _ref15.key;
	        return 'Error in addDataKeys: ' + getTypeError(key, 'key', 'string');
	    },
	
	    'remove:key_type': function removeKey_type(_ref16) {
	        var key = _ref16.key;
	        return 'Error in remove: ' + getTypeError(key, 'key', 'string');
	    },
	
	    'mediate:key_type': function mediateKey_type(_ref17) {
	        var key = _ref17.key;
	        return 'Error in mediate: ' + getTypeError(key, 'key', 'string');
	    }
	};
	
	module.exports = matreshkaError;
	function matreshkaError(key, data) {
	    var getError = errors[key];
	    if (!getError) {
	        throw Error('Unknown error "' + key + '". Please report about this on Github.');
	    }
	
	    return new Error(getError(data));
	}

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var apply = __webpack_require__(8);
	
	// Returns a function, that, as long as it continues to be invoked, will not
	// be triggered. The function will be called after it stops being called for
	// N milliseconds.
	// (c) https://davidwalsh.name/javascript-debounce-function
	
	module.exports = debounce;
	function debounce(func, givenDelay, thisArg) {
	    var timeout = void 0;
	    var delay = void 0;
	    if (typeof delay !== 'number') {
	        thisArg = givenDelay; // eslint-disable-line no-param-reassign
	        delay = 0;
	    }
	
	    delay = givenDelay || 0;
	
	    return function debounced() {
	        var args = arguments;
	        var callContext = thisArg || this;
	
	        clearTimeout(timeout);
	
	        timeout = setTimeout(function () {
	            return apply(func, callContext, args);
	        }, delay);
	    };
	}

/***/ },
/* 8 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = apply;
	function apply(func, context, args) {
	    if (context) {
	        switch (args.length) {
	            case 0:
	                return func.call(context);
	            case 1:
	                return func.call(context, args[0]);
	            case 2:
	                return func.call(context, args[0], args[1]);
	            case 3:
	                return func.call(context, args[0], args[1], args[2]);
	            case 4:
	                return func.call(context, args[0], args[1], args[2], args[3]);
	            default:
	                return func.apply(context, args); // eslint-disable-line prefer-spread
	        }
	    }
	
	    switch (args.length) {
	        case 0:
	            return func();
	        case 1:
	            return func(args[0]);
	        case 2:
	            return func(args[0], args[1]);
	        case 3:
	            return func(args[0], args[1], args[2]);
	        case 4:
	            return func(args[0], args[1], args[2], args[3]);
	        default:
	            return func.apply(undefined, args); // eslint-disable-line prefer-spread
	    }
	}

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var addListener = __webpack_require__(10);
	
	var addTreeListener = __webpack_require__(29);
	
	var matreshkaError = __webpack_require__(6);
	
	// adds a source to a source list and adds needed event listener to a it
	module.exports = addSource;
	function addSource(_ref) {
	    var calcHandler = _ref.calcHandler;
	    var allSources = _ref.allSources;
	    var sourceKey = _ref.sourceKey;
	    var sourceObject = _ref.sourceObject;
	    var eventOptions = _ref.eventOptions;
	    var _eventOptions$exactKe = eventOptions.exactKey;
	    var exactKey = _eventOptions$exactKe === undefined ? false : _eventOptions$exactKe;
	
	    var isDelegated = false;
	
	    // source key must be a string
	    if (typeof sourceKey !== 'string') {
	        throw matreshkaError('calc:source_key_type', { sourceKey: sourceKey });
	    }
	
	    // source object must be an object
	    if (!sourceObject || (typeof sourceObject === 'undefined' ? 'undefined' : _typeof(sourceObject)) !== 'object') {
	        throw matreshkaError('calc:source_object_type', { sourceObject: sourceObject });
	    }
	
	    if (!exactKey) {
	        var deepPath = sourceKey.split('.');
	
	        // if something like a.b.c is used as a key
	        if (deepPath.length > 1) {
	            isDelegated = true;
	            // TODO: Avoid collisions with bindings by using another event name
	            // ... instead of _change:tree:xxx
	            addTreeListener(sourceObject, deepPath, calcHandler);
	        } else {
	            exactKey = true;
	        }
	    }
	
	    if (exactKey) {
	        // normal handler
	        addListener(sourceObject, '_change:deps:' + sourceKey, calcHandler);
	    }
	
	    allSources.push({
	        sourceKey: sourceKey,
	        sourceObject: sourceObject,
	        isDelegated: isDelegated
	    });
	}

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var initMK = __webpack_require__(3);
	
	var triggerOne = __webpack_require__(11);
	
	var defineProp = __webpack_require__(12);
	
	var domEventReg = __webpack_require__(15);
	
	// property modifier event regexp
	var propModEventReg // eslint-disable-next-line max-len
	= /^_change:deps:|^_change:bindings:|^_change:delegated:|^_change:common:|^_change:tree:|^change:|^beforechange:/;
	
	// adds simple event listener
	// used as core of event engine
	module.exports = addListener;
	function addListener(object, name, callback, context) {
	    var info = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];
	
	    var _initMK = initMK(object);
	
	    var allEvents = _initMK.events;
	
	    var ctx = context || object;
	    var events = allEvents[name];
	    var event = { callback: callback, context: context, ctx: ctx, name: name, info: info };
	    // skipChecks is used by internal methods for better performance
	    var _info$skipChecks = info.skipChecks;
	    var skipChecks = _info$skipChecks === undefined ? false : _info$skipChecks;
	
	    if (!skipChecks) {
	        var domEventExecResult = domEventReg.exec(name);
	
	        if (domEventExecResult) {
	            var eventName = domEventExecResult[1];
	            var _domEventExecResult$ = domEventExecResult[2];
	            var key = _domEventExecResult$ === undefined ? 'sandbox' : _domEventExecResult$;
	            var selector = domEventExecResult[3];
	            // fixing circular reference issue
	
	            var addDomListener = __webpack_require__(16);
	
	            addDomListener(object, key, eventName, selector, callback, context, info);
	
	            return true;
	        }
	    }
	
	    // if there are events with the same name
	    if (events) {
	        if (!skipChecks) {
	            // if there are events with the same data, return false
	            for (var i = 0; i < events.length; i++) {
	                var existingEvent = events[i];
	                var argCallback = callback && callback._callback || callback;
	                var eventCallback = existingEvent.callback._callback || existingEvent.callback;
	                if (argCallback === eventCallback && existingEvent.context === context) {
	                    return false;
	                }
	            }
	        }
	
	        // if the event isn't found add it to the event list
	        events.push(event);
	    } else {
	        // if there are no events with the same name, create an array with only  one event
	        allEvents[name] = [event];
	    }
	
	    if (propModEventReg.test(name)) {
	        // define needed accessors for KEY
	        defineProp(object, name.replace(propModEventReg, ''));
	    }
	
	    // names prefixed by underscore mean "private" events
	    if (!skipChecks && name[0] !== '_') {
	        triggerOne(object, 'addevent:' + name, event);
	        triggerOne(object, 'addevent', event);
	    }
	
	    // if event is added successfully return true
	    return true;
	}

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var defs = __webpack_require__(4);
	
	var apply = __webpack_require__(8);
	
	// triggers one event
	module.exports = triggerOne;
	function triggerOne(object, name, triggerArgs) {
	    var def = defs.get(object);
	    var events = def && def.events[name];
	
	    if (events) {
	        var l = events.length;
	        var i = 0;
	
	        // allow to pass both array of args and single arg as triggerArgs
	        if (triggerArgs instanceof Array) {
	            while (i < l) {
	                var event = triggerOne.latestEvent = events[i++];
	                var callback = event.callback;
	                var ctx = event.ctx;
	
	                apply(callback, ctx, triggerArgs);
	            }
	        } else {
	            while (i < l) {
	                var _event = triggerOne.latestEvent = events[i++];
	                var _callback = _event.callback;
	                var _ctx = _event.ctx;
	
	                _callback.call(_ctx, triggerArgs);
	            }
	        }
	    }
	}
	
	// latestEvent is used as required hack in somemethods
	triggerOne.latestEvent = {
	    info: {},
	    name: null
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var defs = __webpack_require__(4);
	
	var _set = __webpack_require__(13);
	
	var matreshkaError = __webpack_require__(6);
	
	function errorAccessor() {
	    throw matreshkaError('common:use_magic_props');
	}
	
	// the function defines needed descriptor for given property
	module.exports = defineProp;
	function defineProp(object, key, noAccessor) {
	    var def = defs.get(object);
	
	    // if no object definition do nothing
	    if (!def) {
	        return null;
	    }
	
	    if (!def.props[key]) {
	        (function () {
	            var propDef = def.props[key] = {
	                value: object[key],
	                mediator: null,
	                bindings: null
	            };
	            var getter = void 0;
	            var setter = void 0;
	
	            // make possible to throw an error on get and on set if sandbox (for all objects)
	            // or container (for Matreshka.Array instances) are used
	            if (key === 'sandbox' || object.isMatreshkaArray && key === 'container') {
	                getter = setter = errorAccessor;
	            }
	
	            if (!noAccessor) {
	                Object.defineProperty(object, key, {
	                    configurable: true,
	                    enumerable: true,
	                    get: function get() {
	                        return getter ? getter() : propDef.value;
	                    },
	                    set: function set(v) {
	                        return setter ? setter() : _set(object, key, v, {
	                            fromSetter: true
	                        });
	                    }
	                });
	            }
	        })();
	    }
	
	    return def.props[key];
	}

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var defs = __webpack_require__(4);
	
	var triggerOne = __webpack_require__(11);
	
	var checkObjectType = __webpack_require__(5);
	
	var is = __webpack_require__(14);
	
	// the function sets new value for a property
	// since its performance is very critical we're checking events existence manually
	module.exports = set;
	function set(object, key, value, eventOptions) {
	    if (_typeof(this) === 'object' && this.isMatreshka) {
	        // when context is Matreshka instance, use this as an object and shift other args
	        /* eslint-disable no-param-reassign */
	        eventOptions = value;
	        value = key;
	        key = object;
	        object = this;
	        /* eslint-enable no-param-reassign */
	    } else {
	        // throw error when object type is wrong
	        checkObjectType(object, 'set');
	    }
	
	    // if no key or falsy key is given
	    if (!key) {
	        return object;
	    }
	
	    // allow to use key-value object as another method variation
	    if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {
	        for (var _target = key, _keys = Object.keys(_target), _i = 0, objKey, objVal, _l = _keys.length; (objKey = _keys[_i], objVal = _target[objKey]), _i < _l; _i++) {
	            set(object, objKey, objVal, value);
	        }
	
	        return object;
	    }
	
	    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign
	    var def = defs.get(object);
	
	    // if no object definition then make simple assignment
	    if (!def) {
	        object[key] = value;
	        return object;
	    }
	
	    var props = def.props;
	    var events = def.events;
	
	    var propDef = props[key];
	
	    // if no property definition then make simple assignment
	    if (!propDef) {
	        object[key] = value;
	        return object;
	    }
	
	    var previousValue = propDef.value;
	    var mediator = propDef.mediator;
	
	    // possible flags, all of them are falsy by default
	
	    var _eventOptions = eventOptions;
	    var skipMediator = _eventOptions.skipMediator;
	    var fromMediator = _eventOptions.fromMediator;
	    var force = _eventOptions.force;
	    var forceHTML = _eventOptions.forceHTML;
	    var silent = _eventOptions.silent;
	    var silentHTML = _eventOptions.silentHTML;
	    var skipCalc = _eventOptions.skipCalc;
	
	    var newValue = void 0;
	
	    if (mediator && !is(value, previousValue) && !skipMediator && !fromMediator) {
	        newValue = mediator(value);
	    } else {
	        newValue = value;
	    }
	
	    var isChanged = !is(newValue, previousValue);
	
	    // add to eventOptions object some useful properties
	
	    var _keys2,
	        _l2,
	        _i2,
	        _source,
	        _key,
	        _result = {};
	
	    _result.value = newValue;
	    _result.self = object;
	    _result.previousValue = previousValue;
	    _result.key = key;
	    _result.isChanged = isChanged;
	
	    for (_source = eventOptions, _keys2 = Object.keys(_source), _l2 = _keys2.length, _i2 = 0; _i2 < _l2; _i2++) {
	        _key = _keys2[_i2];
	        _result[_key] = _source[_key];
	    }
	
	    var extendedEventOptions = _result;
	
	    var triggerChange = (isChanged || force) && !silent;
	
	    // trigger beforechange:KEY and beforechange events
	    if (triggerChange) {
	        var beforechangeStr = 'beforechange';
	        var beforechangeEventName = beforechangeStr + ':' + key;
	
	        if (events[beforechangeEventName]) {
	            triggerOne(object, beforechangeEventName, extendedEventOptions);
	        }
	
	        if (events[beforechangeStr]) {
	            triggerOne(object, beforechangeStr, extendedEventOptions);
	        }
	    }
	
	    propDef.value = newValue;
	
	    // triger bindings
	    if (!silentHTML && (isChanged || forceHTML)) {
	        var changeBindingsEventName = '_change:bindings:' + key;
	        if (events[changeBindingsEventName]) {
	            triggerOne(object, changeBindingsEventName, extendedEventOptions);
	        }
	    }
	
	    // trigger change:KEY and change events
	    if (triggerChange) {
	        var changeStr = 'change';
	        var changeEventName = changeStr + ':' + key;
	        if (events[changeEventName]) {
	            triggerOne(object, changeEventName, extendedEventOptions);
	        }
	
	        if (events[changeStr]) {
	            triggerOne(object, changeStr, extendedEventOptions);
	        }
	    }
	
	    // trigger dependencies made by calc method
	    if ((isChanged || force) && !skipCalc) {
	        var changeDepsEventName = '_change:deps:' + key;
	        if (events[changeDepsEventName]) {
	            triggerOne(object, changeDepsEventName, extendedEventOptions);
	        }
	    }
	
	    if (isChanged) {
	        // trigger common delegated events logic
	        var changeDelegatedKeyEventName = '_change:delegated:' + key;
	        if (events[changeDelegatedKeyEventName]) {
	            triggerOne(object, changeDelegatedKeyEventName, extendedEventOptions);
	        }
	
	        // trigger tree change events logic
	        var changeTreeEventName = '_change:tree:' + key;
	        if (events[changeTreeEventName]) {
	            triggerOne(object, changeTreeEventName, extendedEventOptions);
	        }
	
	        // trigger other internal change events
	        var changeCommonEventName = '_change:common:' + key;
	        if (events[changeCommonEventName]) {
	            triggerOne(object, changeCommonEventName, extendedEventOptions);
	        }
	
	        // trigger delegated logic for asterisk events (*.*.*@foo)
	        // TODO: Confusing events names ("_change:delegated", "_change:common:KEY" etc)
	        var changeDelegatedEventName = '_change:delegated';
	        if (events[changeDelegatedEventName]) {
	            triggerOne(object, changeDelegatedEventName, extendedEventOptions);
	        }
	    }
	
	    return object;
	}

/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	
	// determines whether two values are the same value
	/* istanbul ignore next */
	// eslint-disable-next-line
	
	var isPolyfill = function isPolyfill(v1, v2) {
	  return v1 === 0 && v2 === 0 ? 1 / v1 === 1 / v2 : v1 !== v1 && v2 !== v2 || v1 === v2;
	};
	
	module.exports = Object.is || isPolyfill;

/***/ },
/* 15 */
/***/ function(module, exports) {

	"use strict";
	
	// the regexp allows to parse things like "click::x(.y)"
	// it's shared between few modules
	
	module.exports = /([^::]+)::([^\(\)]+)?(?:\((.*)\))?/;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var initMK = __webpack_require__(3);
	
	var defineProp = __webpack_require__(12);
	
	var addListener = __webpack_require__(10);
	
	var dom = __webpack_require__(17);
	
	var createDomEventHandler = __webpack_require__(28);
	
	// returns an object with event handlers used at addDomListener
	function createBindingHandlers(_ref) {
	    var fullEventName = _ref.fullEventName;
	    var domEventHandler = _ref.domEventHandler;
	    var selector = _ref.selector;
	
	    return {
	        bindHandler: function bindHandler() {
	            var evt = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	            var node = evt.node;
	
	            if (node) {
	                dom.$(node).on(fullEventName, selector, domEventHandler);
	            }
	        },
	        unbindHandler: function unbindHandler() {
	            var evt = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	            var node = evt.node;
	
	            if (node) {
	                dom.$(node).off(fullEventName, selector, domEventHandler);
	            }
	        }
	    };
	}
	
	// adds DOM event listener for nodes bound to given property
	module.exports = addDomListener;
	function addDomListener(object, key, eventName, selector, callback, context, info) {
	    var def = initMK(object);
	    var propDef = defineProp(object, key);
	
	    var domEventHandler = createDomEventHandler({
	        key: key,
	        object: object,
	        callback: callback,
	        context: context
	    });
	
	    // making possible to remove this event listener
	    domEventHandler._callback = callback;
	
	    var eventNamespace = def.id + key;
	    var fullEventName = eventName + '.' + eventNamespace;
	
	    var _createBindingHandler = createBindingHandlers({
	        fullEventName: fullEventName,
	        domEventHandler: domEventHandler,
	        selector: selector
	    });
	
	    var bindHandler = _createBindingHandler.bindHandler;
	    var unbindHandler = _createBindingHandler.unbindHandler;
	
	    var addBindListenerResult = addListener(object, 'bind:' + key, bindHandler, context, info);
	    var addUnbindListenerResult = addListener(object, 'unbind:' + key, unbindHandler, context, info);
	
	    // if events are added successfully then run bindHandler for every node immediately
	    // TODO: Describe why do we need addBindListenerResult and addUnbindListenerResult
	    if (addBindListenerResult && addUnbindListenerResult) {
	        var bindings = propDef.bindings;
	
	        if (bindings) {
	            for (var _target = bindings, _index = 0, _ref2, _l = _target.length; _ref2 = _target[_index], _index < _l; _index++) {
	                var node = _ref2.node;
	                return bindHandler({ node: node });
	            }
	        }
	    }
	
	    return object;
	}

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var $ = __webpack_require__(18);
	
	module.exports = { $: $ };

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var mq = __webpack_require__(19);
	
	// check existence of needed methods in $ global variable
	// to use it for internal needs
	
	var neededMethods = ['on', 'off', 'add']; /* global $ */
	
	var globalDollar = typeof $ === 'function' ? $ : null;
	var useGlobalDollar = true;
	
	/* istanbul ignore if */
	if (globalDollar) {
	    var fn = globalDollar.fn || globalDollar.prototype;
	    for (var i = 0; i < neededMethods.length; i++) {
	        if (!fn[neededMethods[i]]) {
	            useGlobalDollar = false;
	            break;
	        }
	    }
	
	    if (!globalDollar.parseHTML) {
	        // Zepto doesn't include its own parseHTML
	        // TODO: Assignment of parseHTML is side effect
	        globalDollar.parseHTML = mq.parseHTML;
	    }
	} else {
	    useGlobalDollar = false;
	}
	
	module.exports = useGlobalDollar ? globalDollar : mq;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Init = __webpack_require__(20);
	
	var parseHTML = __webpack_require__(22);
	
	var on = __webpack_require__(23);
	
	var off = __webpack_require__(25);
	
	var add = __webpack_require__(26);
	
	var assign = __webpack_require__(27);
	
	// tiny jQuery replacement for Matreshka
	// mq previously called balalaika.js
	module.exports = mq;
	function mq(selector, context) {
	    return new Init(selector, context);
	}
	
	mq.parseHTML = parseHTML;
	
	assign(Init.prototype, {
	    on: on,
	    off: off,
	    add: add
	});

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var html2nodeList = __webpack_require__(21);
	
	var win = window;
	
	// function-constructor of mq library
	// accepts many kinds of arguments (selector, html, function)
	function MQInit(selector, context) {
	    var result = void 0;
	
	    if (selector) {
	        if (selector.nodeType || (typeof win === 'undefined' ? 'undefined' : _typeof(win)) === 'object' && selector === win) {
	            result = [selector];
	        } else if (typeof selector === 'string') {
	            if (/</.test(selector)) {
	                result = html2nodeList(selector);
	            } else if (context) {
	                var newContext = new MQInit(context)[0];
	
	                if (newContext) {
	                    result = newContext.querySelectorAll(selector);
	                }
	            } else {
	                result = win.document.querySelectorAll(selector);
	            }
	        } else if ('length' in selector) {
	            // if it's something array-like (eg NodeList)
	            result = selector;
	        } else {
	            // this is somethong another (eg Attr)
	            result = [selector];
	        }
	    }
	
	    var length = result && result.length;
	
	    if (length) {
	        for (var i = 0; i < length; i++) {
	            this.push(result[i]);
	        }
	    }
	}
	
	MQInit.prototype = [];
	
	module.exports = MQInit;

/***/ },
/* 21 */
/***/ function(module, exports) {

	'use strict';
	
	// converts HTML string to NodeList instance
	
	module.exports = html2nodeList;
	function html2nodeList(givenHTML) {
	    // wrapMap is taken from jQuery
	    var wrapMap = {
	        option: [1, '<select multiple="multiple">', '</select>'],
	        legend: [1, '<fieldset>', '</fieldset>'],
	        thead: [1, '<table>', '</table>'],
	        tr: [2, '<table><tbody>', '</tbody></table>'],
	        td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],
	        col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	        area: [1, '<map>', '</map>'],
	        _: [0, '', '']
	    };
	
	    var html = givenHTML.replace(/^\s+|\s+$/g, '');
	    var node = window.document.createElement('div');
	    var i = void 0;
	
	    wrapMap.optgroup = wrapMap.option;
	    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	    wrapMap.th = wrapMap.td;
	
	    var ex = /<([\w:]+)/.exec(html);
	    var wrapper = ex && wrapMap[ex[1]] || wrapMap._;
	
	    node.innerHTML = wrapper[1] + html + wrapper[2];
	
	    i = wrapper[0];
	
	    while (i--) {
	        node = node.children[0];
	    }
	
	    return node.childNodes;
	}

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var html2nodeList = __webpack_require__(21);
	
	var Init = __webpack_require__(20);
	
	// parses given HTML and returns mq instance
	module.exports = parseHTML;
	function parseHTML(html) {
	    return new Init(html2nodeList(html));
	}

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var data = __webpack_require__(24);
	
	var splitBySpaceReg = /\s+/;
	var splitByDotReg = /\.(.+)/;
	
	// checks an element against a selector
	function is(node, selector) {
	    return (node.matches || node.webkitMatchesSelector || node.mozMatchesSelector || node.msMatchesSelector || node.oMatchesSelector).call(node, selector);
	}
	
	// the function is used when a selector is given
	function delegateHandler(evt, selector, handler) {
	    var randomID = Math.random().toString().replace('0.', 'x');
	    var scopeSelector = '[' + randomID + '="' + randomID + '"] ';
	    var splittedSelector = selector.split(',');
	
	    var matching = '';
	
	    for (var i = 0; i < splittedSelector.length; i++) {
	        var sel = splittedSelector[i];
	        matching += '' + (i === 0 ? '' : ',') + scopeSelector + sel + ',' + scopeSelector + sel + ' *';
	    }
	
	    this.setAttribute(randomID, randomID);
	
	    if (is(evt.target, matching)) {
	        handler.call(this, evt);
	    }
	
	    this.removeAttribute(randomID);
	}
	
	// adds event listener to a set of elemnts
	module.exports = on;
	function on(namesStr, selector, handler) {
	    var names = namesStr.split(splitBySpaceReg);
	    var delegate = void 0;
	
	    if (typeof selector === 'function') {
	        handler = selector; // eslint-disable-line no-param-reassign
	        selector = null; // eslint-disable-line no-param-reassign
	    }
	
	    if (selector) {
	        delegate = function uniqueDelegateHandler(evt) {
	            delegateHandler.call(this, evt, selector, handler);
	        };
	    }
	
	    for (var i = 0; i < names.length; i++) {
	        var _names$i$split = names[i].split(splitByDotReg);
	
	        var name = _names$i$split[0];
	        var namespace = _names$i$split[1];
	
	        for (var j = 0; j < this.length; j++) {
	            var node = this[j];
	            var nodeID = node.b$ = node.b$ || ++data.nodeIndex;
	            var events = data.allEvents[name + nodeID] = data.allEvents[name + nodeID] || [];
	
	            var exist = false;
	
	            for (var k = 0; k < events.length; k++) {
	                var event = events[k];
	
	                if (handler === event.handler && (!selector || selector === event.selector)) {
	                    exist = true;
	                    break;
	                }
	            }
	
	            if (!exist) {
	                events.push({
	                    delegate: delegate,
	                    handler: handler,
	                    namespace: namespace,
	                    selector: selector
	                });
	
	                node.addEventListener(name, delegate || handler, false);
	            }
	        }
	    }
	
	    return this;
	}

/***/ },
/* 24 */
/***/ function(module, exports) {

	"use strict";
	
	// an object allows to share data between modules; it's needed because we use
	// simplified ES modules there and cannot import and share a number
	
	module.exports = {
	    nodeIndex: 0,
	    allEvents: {}
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var data = __webpack_require__(24);
	
	var splitBySpaceReg = /\s+/;
	var splitByDotReg = /\.(.+)/;
	
	// removes event handler from a set of elements
	module.exports = off;
	function off(namesStr, selector, handler) {
	    if (typeof selector === 'function') {
	        handler = selector; // eslint-disable-line no-param-reassign
	        selector = null; // eslint-disable-line no-param-reassign
	    }
	
	    var names = namesStr.split(splitBySpaceReg);
	
	    for (var i = 0; i < names.length; i++) {
	        var _names$i$split = names[i].split(splitByDotReg);
	
	        var name = _names$i$split[0];
	        var namespace = _names$i$split[1];
	
	        for (var j = 0; j < this.length; j++) {
	            var node = this[j];
	            var events = data.allEvents[name + node.b$];
	
	            if (events) {
	                for (var k = 0; k < events.length; k++) {
	                    var event = events[k];
	                    if ((!handler || handler === event.handler || handler === event.delegate) && (!namespace || namespace === event.namespace) && (!selector || selector === event.selector)) {
	                        node.removeEventListener(name, event.delegate || event.handler);
	                        events.splice(k--, 1);
	                    }
	                }
	            } else if (!namespace && !selector) {
	                node.removeEventListener(name, handler);
	            }
	        }
	    }
	
	    return this;
	}

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Init = __webpack_require__(20);
	
	var data = __webpack_require__(24);
	
	// adds unique nodes to mq collection
	module.exports = add;
	function add(selector) {
	    var idMap = {};
	
	    var result = void 0;
	
	    var nodes = new Init(selector);
	
	    if (this.length) {
	        result = new Init();
	        for (var i = 0; i < this.length; i++) {
	            var node = this[i];
	            var nodeID = node.b$ = node.b$ || ++data.nodeIndex;
	            idMap[nodeID] = 1;
	            result.push(node);
	        }
	
	        for (var _i = 0; _i < nodes.length; _i++) {
	            var _node = nodes[_i];
	            var _nodeID = _node.b$ = _node.b$ || ++data.nodeIndex;
	            if (!idMap[_nodeID]) {
	                idMap[_nodeID] = 1;
	                result.push(_node);
	            }
	        }
	    } else {
	        result = nodes;
	    }
	
	    return result;
	}

/***/ },
/* 27 */
/***/ function(module, exports) {

	'use strict';
	
	// Object.assign polyfyll
	/* istanbul ignore next */
	
	var assign = Object.assign || function assign(target) {
	    /* istanbul ignore next */
	    if (target === undefined || target === null) {
	        throw new TypeError('Cannot convert undefined or null to object');
	    }
	
	    var output = Object(target);
	
	    for (var index = 1; index < arguments.length; index++) {
	        var source = arguments[index];
	        if (source !== undefined && source !== null) {
	            for (var _target = source, _keys = Object.keys(_target), _i = 0, nextKey, nextValue, _l = _keys.length; (nextKey = _keys[_i], nextValue = _target[nextKey]), _i < _l; _i++) {
	                output[nextKey] = nextValue;
	            }
	        }
	    }
	
	    return output;
	};
	
	module.exports = assign;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var apply = __webpack_require__(8);
	
	// returns DOM event handler
	module.exports = createDomEventHandler;
	function createDomEventHandler(_ref) {
	    var key = _ref.key;
	    var object = _ref.object;
	    var callback = _ref.callback;
	    var context = _ref.context;
	
	    return function domEventHandler(domEvent) {
	        var originalEvent = domEvent.originalEvent || domEvent;
	        // matreshkaTriggerArgs are created when DOM event is triggered by trigger method
	        var triggerArgs = originalEvent.matreshkaTriggerArgs;
	        var which = domEvent.which;
	        var target = domEvent.target;
	        var ctrlKey = domEvent.ctrlKey;
	        var altKey = domEvent.altKey;
	
	        if (triggerArgs) {
	            // if args are passed to trigger method then pass them to an event handler
	            apply(callback, context, triggerArgs);
	        } else {
	            // use the following object as an arg for event handler
	            callback.call(context, {
	                self: object,
	                node: this,
	                preventDefault: function preventDefault() {
	                    return domEvent.preventDefault();
	                },
	                stopPropagation: function stopPropagation() {
	                    return domEvent.stopPropagation();
	                },
	                key: key,
	                domEvent: domEvent,
	                originalEvent: originalEvent,
	                which: which,
	                target: target,
	                ctrlKey: ctrlKey,
	                altKey: altKey
	            });
	        }
	    };
	}

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var delegateListener = __webpack_require__(30);
	
	var removeTreeListener = __webpack_require__(39);
	
	// creates tree listener
	function createTreeListener(_ref) {
	    var handler = _ref.handler;
	    var restPath = _ref.restPath;
	
	    var newHandler = function treeListener(changeEvent) {
	        var _keys,
	            _l,
	            _i,
	            _source,
	            _key,
	            _result = {};
	
	        _result.restPath = restPath;
	
	        for (_source = changeEvent, _keys = Object.keys(_source), _l = _keys.length, _i = 0; _i < _l; _i++) {
	            _key = _keys[_i];
	            _result[_key] = _source[_key];
	        }
	
	        var extendedChangeEvent = _result;
	        var previousValue = changeEvent.previousValue;
	        var value = changeEvent.value;
	
	        // removes listener for all branches of the path on old object
	
	        if (previousValue && (typeof previousValue === 'undefined' ? 'undefined' : _typeof(previousValue)) === 'object') {
	            removeTreeListener(previousValue, restPath, handler);
	        }
	
	        // adds listener for all branches of "restPath" path on newly assigned object
	        if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	            addTreeListener(value, restPath, handler);
	        }
	
	        // call original handler
	        handler.call(this, extendedChangeEvent);
	    };
	
	    newHandler._callback = handler;
	
	    return newHandler;
	}
	
	// listens changes for all branches of given path
	// TODO: Pass context to addTreeListener
	// one of the most hard functions to understand
	module.exports = addTreeListener;
	function addTreeListener(object, deepPath, handler) {
	    if (typeof deepPath === 'string') {
	        deepPath = deepPath.split('.'); // eslint-disable-line no-param-reassign
	    }
	
	    // iterate over all keys and delegate listener for all objects of given branch
	    for (var i = 0; i < deepPath.length; i++) {
	        // TODO: Array.prototype.slice method is slow
	        var listenPath = deepPath.slice(0, i);
	        var restPath = deepPath.slice(i + 1);
	
	        delegateListener(object, listenPath, '_change:tree:' + deepPath[i], createTreeListener({
	            handler: handler,
	            restPath: restPath
	        }));
	    }
	}

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var addListener = __webpack_require__(10);
	
	var defs = __webpack_require__(4);
	
	var arrayAddHandler = __webpack_require__(31);
	
	var objectSetHandler = __webpack_require__(32);
	
	var arrayRemoveHandler = __webpack_require__(33);
	
	var objectRemoveHandler = __webpack_require__(37);
	
	var changeHandler = __webpack_require__(38);
	
	// adds delegated event listener to an object by given path
	module.exports = delegateListener;
	function delegateListener(object, givenPath, name, callback, context) {
	    var info = arguments.length <= 5 || arguments[5] === undefined ? {} : arguments[5];
	
	    // if typeof path is string and path is not empty string then split it
	    var path = typeof givenPath === 'string' && givenPath !== '' ? givenPath.split('.') : givenPath;
	
	    if (!path || !path.length) {
	        // if no path then add simple listener
	        addListener(object, name, callback, context, info);
	    } else {
	        // else do all magic
	        var key = path[0];
	        var pathStr = void 0; // needed for undelegation
	
	        if (path.length > 1) {
	            var _source = path,
	                _l = _source.length,
	                _i = 1 || 0,
	                _end = null || _l,
	                _j = 0,
	                _result = Array(_end - _i);
	
	            while (_i < _end) {
	                _result[_j++] = _source[_i++];
	            }
	
	            path = _result;
	            pathStr = path.join('.');
	        } else {
	            path = [];
	            pathStr = path[0] || '';
	        }
	
	        var delegatedData = {
	            path: path,
	            name: name,
	            callback: callback,
	            context: context,
	            info: info,
	            object: object
	        };
	
	        if (key === '*') {
	            // handling asterisk events
	            if (object.isMatreshkaArray) {
	                // the event is triggered when something is added to an array
	                addListener(object, '_asterisk:add', arrayAddHandler, null, {
	                    delegatedData: delegatedData,
	                    pathStr: pathStr
	                });
	
	                // the event is triggered when something is removed from an array
	                addListener(object, '_asterisk:remove', arrayRemoveHandler, null, {
	                    delegatedData: delegatedData,
	                    pathStr: pathStr
	                });
	
	                // call handler manually to delegate listener for currently existing data props
	                arrayAddHandler({
	                    added: object
	                }, delegatedData);
	            } else if (object.isMatreshkaObject) {
	                var def = defs.get(object);
	
	                // the event is triggered when data prop is changed
	                addListener(object, '_asterisk:set', objectSetHandler, null, {
	                    delegatedData: delegatedData,
	                    pathStr: pathStr
	                });
	
	                // the event is triggered when data prop is removed
	                addListener(object, '_asterisk:remove', objectRemoveHandler, null, {
	                    delegatedData: delegatedData,
	                    pathStr: pathStr
	                });
	
	                // delegate listener for currently existing data props
	
	                for (var _target = def.keys, _keys = Object.keys(_target), _i2 = 0, defKey, _, _l2 = _keys.length; (defKey = _keys[_i2], _ = _target[defKey]), _i2 < _l2; _i2++) {
	                    var item = object[defKey];
	                    if (item && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {
	                        delegateListener(item, path, name, callback, context, info);
	                    }
	                }
	            }
	        } else {
	            // handling non-asterisk delegated event
	
	            // the event is triggered by "set"
	            addListener(object, '_change:delegated:' + key, changeHandler, null, {
	                delegatedData: delegatedData,
	                pathStr: pathStr
	            });
	
	            // call handler manually
	            changeHandler({
	                value: object[key]
	            }, delegatedData);
	        }
	    }
	}

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var triggerOne = __webpack_require__(11);
	
	// the function is called when something is added to an array
	// it delegates asterisk listener for newly added items
	module.exports = arrayAddHandler;
	function arrayAddHandler(_ref) {
	    var added = _ref.added;
	
	    var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? triggerOne.latestEvent.info.delegatedData : arguments[1];
	
	    var path = _ref2.path;
	    var name = _ref2.name;
	    var callback = _ref2.callback;
	    var context = _ref2.context;
	    var info = _ref2.info;
	
	    for (var _target = added, _index = 0, item, _l = _target.length; item = _target[_index], _index < _l; _index++) {
	        if (item && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {
	            var delegateListener = __webpack_require__(30); // fixing circular ref
	
	            delegateListener(item, path, name, callback, context, info);
	        }
	    }
	}

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var triggerOne = __webpack_require__(11);
	
	var defs = __webpack_require__(4);
	
	// the function is called when data property is changed in Matreshka.Object
	// it delegates asterisk listener for new value
	module.exports = objectSetHandler;
	function objectSetHandler(_ref) {
	    var key = _ref.key;
	
	    var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? triggerOne.latestEvent.info.delegatedData : arguments[1];
	
	    var path = _ref2.path;
	    var name = _ref2.name;
	    var callback = _ref2.callback;
	    var context = _ref2.context;
	    var info = _ref2.info;
	    var object = _ref2.object;
	
	    if (key) {
	        var item = object[key];
	
	        if (item && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {
	            var def = defs.get(object);
	            if (key in def.keys) {
	                var delegateListener = __webpack_require__(30); // fixing circular ref
	
	                delegateListener(item, path, name, callback, context, info);
	            }
	        }
	    }
	}

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var undelegateListener = __webpack_require__(34);
	
	var triggerOne = __webpack_require__(11);
	
	// the function is called when something is removed from an array
	// it undelegates asterisk listener from removed items
	module.exports = arrayRemoveHandler;
	function arrayRemoveHandler(_ref) {
	    var removed = _ref.removed;
	
	    var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? triggerOne.latestEvent.info.delegatedData : arguments[1];
	
	    var path = _ref2.path;
	    var name = _ref2.name;
	    var callback = _ref2.callback;
	    var context = _ref2.context;
	    var info = _ref2.info;
	
	    if (removed && removed.length) {
	        for (var _target = removed, _index = 0, item, _l = _target.length; item = _target[_index], _index < _l; _index++) {
	            if (item && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {
	                undelegateListener(item, path, name, callback, context, info);
	            }
	        }
	    }
	}

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var defs = __webpack_require__(4);
	
	var removeListener = __webpack_require__(35);
	
	// the function removes internally used events such as _asterisk:add
	function detatchDelegatedLogic(_ref) {
	    var delegatedEventName = _ref.delegatedEventName;
	    var pathStr = _ref.pathStr;
	    var allEvents = _ref.allEvents;
	
	    var retain = [];
	    var events = allEvents[delegatedEventName];
	
	    for (var _target = events, _index = 0, event, _l = _target.length; event = _target[_index], _index < _l; _index++) {
	        // pathStr is assigned to info in delegateListener
	        if (event.info.pathStr !== pathStr) {
	            retain.push(event);
	        }
	    }
	
	    if (retain.length) {
	        allEvents[delegatedEventName] = retain;
	    } else {
	        delete allEvents[delegatedEventName];
	    }
	}
	
	// removes delegated event listener from an object by given path
	module.exports = undelegateListener;
	function undelegateListener(object, givenPath, name, callback, context) {
	    var info = arguments.length <= 5 || arguments[5] === undefined ? {} : arguments[5];
	
	    var def = defs.get(object);
	
	    // if no definition do nothing
	    if (!def) {
	        return;
	    }
	
	    var allEvents = def.events;
	
	    var path = typeof givenPath === 'string' && givenPath !== '' ? givenPath.split('.') : givenPath;
	
	    if (!path || !path.length) {
	        // if no path then remove listener
	        removeListener(object, name, callback, context, info);
	    } else {
	        // else do all magic
	        var key = path[0];
	        var pathStr = void 0;
	
	        if (path.length > 1) {
	            var _source = path,
	                _l2 = _source.length,
	                _i = 1 || 0,
	                _end = null || _l2,
	                _j = 0,
	                _result = Array(_end - _i);
	
	            while (_i < _end) {
	                _result[_j++] = _source[_i++];
	            }
	
	            path = _result;
	            pathStr = path.join('.');
	        } else {
	            path = [];
	            pathStr = path[0] || '';
	        }
	
	        if (key === '*') {
	            // remove asterisk events
	            if (object.isMatreshkaArray) {
	                var delegatedAddEvtName = '_asterisk:add';
	                if (allEvents[delegatedAddEvtName]) {
	                    detatchDelegatedLogic({
	                        delegatedEventName: delegatedAddEvtName,
	                        pathStr: pathStr,
	                        allEvents: allEvents
	                    });
	                }
	
	                var delegatedRemoveEvtName = '_asterisk:remove';
	                if (allEvents[delegatedRemoveEvtName]) {
	                    detatchDelegatedLogic({
	                        delegatedEventName: delegatedRemoveEvtName,
	                        pathStr: pathStr,
	                        allEvents: allEvents
	                    });
	                }
	
	                // undelegate asterisk events for existing items
	                if (object.length) {
	                    for (var _target2 = object, _index2 = 0, item, _l3 = _target2.length; item = _target2[_index2], _index2 < _l3; _index2++) {
	                        if (item && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {
	                            undelegateListener(item, path, name, callback, context, info);
	                        }
	                    }
	                }
	            } else if (object.isMatreshkaObject) {
	                var delegatedSetEvtName = '_asterisk:set';
	                if (allEvents[delegatedSetEvtName]) {
	                    detatchDelegatedLogic({
	                        delegatedEventName: delegatedSetEvtName,
	                        pathStr: pathStr,
	                        allEvents: allEvents
	                    });
	                }
	
	                var _delegatedRemoveEvtName = '_asterisk:remove';
	                if (allEvents[_delegatedRemoveEvtName]) {
	                    detatchDelegatedLogic({
	                        delegatedEventName: _delegatedRemoveEvtName,
	                        pathStr: pathStr,
	                        allEvents: allEvents
	                    });
	                }
	
	                object.each(function (item) {
	                    if (item && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {
	                        undelegateListener(item, path, name, callback, context, info);
	                    }
	                });
	            }
	        } else {
	            // remove non-asterisk delegated events
	
	            var delegatedChangeEvtName = '_change:delegated:' + key;
	            if (allEvents[delegatedChangeEvtName]) {
	                detatchDelegatedLogic({
	                    delegatedEventName: delegatedChangeEvtName,
	                    pathStr: pathStr,
	                    allEvents: allEvents
	                });
	            }
	
	            if (_typeof(object[key]) === 'object') {
	                undelegateListener(object[key], path, name, callback, context, info);
	            }
	        }
	    }
	}

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var defs = __webpack_require__(4);
	
	var triggerOne = __webpack_require__(11);
	
	var domEventReg = __webpack_require__(15);
	
	// removes simple event listener from an object
	module.exports = removeListener;
	function removeListener(object, name, callback, context, info) {
	    var def = defs.get(object);
	
	    // if no definition do nothing
	    if (!def) {
	        return false;
	    }
	
	    var allEvents = def.events;
	
	    var events = allEvents[name];
	    var retain = [];
	    var noTrigger = name ? name[0] === '_' : false;
	    var domEventExecResult = domEventReg.exec(name);
	
	    if (domEventExecResult) {
	        var eventName = domEventExecResult[1];
	        var _domEventExecResult$ = domEventExecResult[2];
	        var key = _domEventExecResult$ === undefined ? 'sandbox' : _domEventExecResult$;
	        var selector = domEventExecResult[3];
	        // fixing circular reference issue
	
	        var removeDomListener = __webpack_require__(36);
	
	        removeDomListener(object, key, eventName, selector, callback, context, info);
	
	        return true;
	    }
	
	    // if all events need to be removed
	    if (typeof name === 'undefined') {
	        if (!noTrigger) {
	            for (var _target2 = allEvents, _keys = Object.keys(_target2), _i = 0, allEventsName, allEventsItem, _l2 = _keys.length; (allEventsName = _keys[_i], allEventsItem = _target2[allEventsName]), _i < _l2; _i++) {
	                for (var _target = allEventsItem, _index = 0, event, _l = _target.length; event = _target[_index], _index < _l; _index++) {
	                    var removeEventData = {
	                        allEventsName: allEventsName,
	                        callback: event.callback,
	                        context: event.context
	                    };
	
	                    triggerOne(object, 'removeevent:' + name, removeEventData);
	                    triggerOne(object, 'removeevent', removeEventData);
	                }
	            }
	        }
	
	        // restore default value of "events"
	        def.events = {};
	    } else if (events) {
	        for (var _target3 = events, _index2 = 0, event, _l3 = _target3.length; event = _target3[_index2], _index2 < _l3; _index2++) {
	            var argCallback = callback && callback._callback || callback;
	            var eventCallback = event.callback._callback || event.callback;
	
	            if (argCallback && argCallback !== eventCallback || context && context !== event.context) {
	                // keep event
	                retain.push(event);
	            } else {
	                var _removeEventData = {
	                    name: name,
	                    callback: event.callback,
	                    context: event.context
	                };
	
	                if (!noTrigger) {
	                    triggerOne(object, 'removeevent:' + name, _removeEventData);
	                    triggerOne(object, 'removeevent', _removeEventData);
	                }
	            }
	        }
	        // if events with given name are found
	
	
	        if (retain.length) {
	            allEvents[name] = retain;
	        } else {
	            delete def.events[name];
	        }
	    }
	
	    return false;
	}

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var defs = __webpack_require__(4);
	
	var removeListener = __webpack_require__(35);
	
	var dom = __webpack_require__(17);
	
	// removes dom listener from nodes bound to given key
	module.exports = removeDomListener;
	function removeDomListener(object, key, eventName, selector, callback, context, info) {
	    var def = defs.get(object);
	
	    if (!def) {
	        return object;
	    }
	
	    var props = def.props;
	
	    var propDef = props[key];
	
	    if (!propDef) {
	        return object;
	    }
	
	    var bindings = propDef.bindings;
	
	    if (bindings) {
	        (function () {
	            // collect bound nodes and remove DOM event listener
	            var nodes = Array(bindings.length);
	            var eventNamespace = def.id + key;
	
	            for (var _target = bindings, index = 0, binding, _l = _target.length; binding = _target[index], index < _l; index++) {
	                nodes[index] = binding.node;
	            }
	
	            dom.$(nodes).off(eventName + '.' + eventNamespace, selector, callback);
	        })();
	    }
	
	    // remove bind and unbind listeners from given key
	    removeListener(object, 'bind:' + key, callback, context, info);
	    removeListener(object, 'unbind:' + key, callback, context, info);
	
	    return object;
	}

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var undelegateListener = __webpack_require__(34);
	
	var triggerOne = __webpack_require__(11);
	
	// the function is called when data property is removed from Matreshka.Object
	// it undelegates asterisk listener from removed object
	module.exports = objectRemoveHandler;
	function objectRemoveHandler(_ref) {
	    var item = _ref.value;
	
	    var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? triggerOne.latestEvent.info.delegatedData : arguments[1];
	
	    var path = _ref2.path;
	    var name = _ref2.name;
	    var callback = _ref2.callback;
	    var context = _ref2.context;
	    var info = _ref2.info;
	
	    if (item && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {
	        undelegateListener(item, path, name, callback, context, info);
	    }
	}

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var undelegateListener = __webpack_require__(34);
	
	var triggerOne = __webpack_require__(11);
	
	// the function is called when some part of a path is changed
	// it delegates event listener for new branch of an object and undelegates it for old one
	// used for non-asterisk events
	module.exports = changeHandler;
	function changeHandler(_ref) {
	    var previousValue = _ref.previousValue;
	    var value = _ref.value;
	
	    var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? triggerOne.latestEvent.info.delegatedData : arguments[1];
	
	    var path = _ref2.path;
	    var name = _ref2.name;
	    var callback = _ref2.callback;
	    var context = _ref2.context;
	    var info = _ref2.info;
	
	    if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	        var delegateListener = __webpack_require__(30); // fixing circular ref
	
	        delegateListener(value, path, name, callback, context, info);
	    }
	
	    if (previousValue && (typeof previousValue === 'undefined' ? 'undefined' : _typeof(previousValue)) === 'object') {
	        undelegateListener(previousValue, path, name, callback, context, info);
	    }
	}

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var undelegateListener = __webpack_require__(34);
	
	// removes tree listener from all object tree of fiven path
	// TODO: Pass context to removeTreeListener
	module.exports = removeTreeListener;
	function removeTreeListener(object, deepPath, handler) {
	    if (typeof deepPath === 'string') {
	        deepPath = deepPath.split('.'); // eslint-disable-line no-param-reassign
	    }
	
	    // iterate over keys of the path and undelegate given handler (can be undefined)
	    for (var i = 0; i < deepPath.length; i++) {
	        // TODO: Array.prototype.slice is slow
	        var listenedPath = deepPath.slice(0, i);
	
	        undelegateListener(object, listenedPath, '_change:tree:' + deepPath[i], handler);
	    }
	}

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var set = __webpack_require__(13);
	
	var deepFind = __webpack_require__(41);
	
	var apply = __webpack_require__(8);
	
	// creates event handler for target object which will be fired when a source is changed
	module.exports = createCalcHandler;
	function createCalcHandler(_ref) {
	    var object = _ref.object;
	    var eventOptions = _ref.eventOptions;
	    var allSources = _ref.allSources;
	    var target = _ref.target;
	    var def = _ref.def;
	    var handler = _ref.handler;
	
	    return function calcHandler() {
	        var changeEvent = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	        var values = [];
	        var _changeEvent$protecto = changeEvent.protector;
	        var protector = _changeEvent$protecto === undefined ? {} : _changeEvent$protecto;
	
	        var protectKey = target + def.id;
	
	        var _keys,
	            _l,
	            _i,
	            _source,
	            _key,
	            _result = {};
	
	        _result.protector = protector;
	
	        for (_source = eventOptions, _keys = Object.keys(_source), _l = _keys.length, _i = 0; _i < _l; _i++) {
	            _key = _keys[_i];
	            _result[_key] = _source[_key];
	        }
	
	        for (_source = changeEvent, _keys = Object.keys(_source), _l = _keys.length, _i = 0; _i < _l; _i++) {
	            _key = _keys[_i];
	            _result[_key] = _source[_key];
	        }
	
	        var setEventOptions = _result;
	
	        if (protectKey in protector) {
	            return;
	        }
	
	        protector[protectKey] = true;
	
	        for (var _target = allSources, _index = 0, _ref2, _l2 = _target.length; _ref2 = _target[_index], _index < _l2; _index++) {
	            var sourceObject = _ref2.sourceObject;
	            var sourceKey = _ref2.sourceKey;
	            var isDelegated = _ref2.isDelegated;
	
	            var value = isDelegated ? deepFind(sourceObject, sourceKey) : sourceObject[sourceKey];
	            values.push(value);
	        }
	
	        var targetValue = apply(handler, object, values);
	        set(object, target, targetValue, setEventOptions);
	    };
	}

/***/ },
/* 41 */
/***/ function(module, exports) {

	'use strict';
	
	// gets value of a property in nested object
	// eg "d" from a.b.c.d
	
	module.exports = deepFind;
	function deepFind(obj, givenPath) {
	    var paths = typeof givenPath === 'string' ? givenPath.split('.') : givenPath;
	    var current = obj;
	
	    for (var i = 0; i < paths.length; ++i) {
	        if (typeof current[paths[i]] === 'undefined') {
	            return undefined;
	        }
	
	        current = current[paths[i]];
	    }
	
	    return current;
	}

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var splitBySpaceReg = __webpack_require__(43);
	
	var checkObjectType = __webpack_require__(5);
	
	var matreshkaError = __webpack_require__(6);
	
	var addListener = __webpack_require__(10);
	
	var delegateListener = __webpack_require__(30);
	
	// adds event listener
	module.exports = on;
	function on(object, givenNames, callback, triggerOnInit, context) {
	    if (_typeof(this) === 'object' && this.isMatreshka) {
	        // when context is Matreshka instance, use this as an object and shift other args
	        /* eslint-disable no-param-reassign */
	        context = triggerOnInit;
	        triggerOnInit = callback;
	        callback = givenNames;
	        givenNames = object;
	        object = this;
	        /* eslint-enable no-param-reassign */
	    } else {
	        // throw error when object type is wrong
	        checkObjectType(object, 'on');
	    }
	
	    var isNamesVarArray = givenNames instanceof Array;
	
	    // allow to pass name-handler object
	    if (givenNames && (typeof givenNames === 'undefined' ? 'undefined' : _typeof(givenNames)) === 'object' && !isNamesVarArray) {
	        for (var _target = givenNames, _keys = Object.keys(_target), _i = 0, namesObjName, namesObjCallback, _l = _keys.length; (namesObjName = _keys[_i], namesObjCallback = _target[namesObjName]), _i < _l; _i++) {
	            on(object, namesObjName, namesObjCallback, callback, triggerOnInit);
	        }
	
	        return object;
	    }
	
	    if (typeof givenNames !== 'string' && !isNamesVarArray) {
	        throw matreshkaError('on:names_type', { names: givenNames });
	    }
	
	    // split by spaces
	    // TODO: Array of names passed to on method is non-documented feature
	    var names = isNamesVarArray ? givenNames : givenNames.split(splitBySpaceReg);
	
	    // flip triggerOnInit and context when triggerOnInit is not boolean
	    if (typeof triggerOnInit !== 'boolean' && typeof triggerOnInit !== 'undefined') {
	        var _ref = [triggerOnInit, context];
	        // eslint-disable-next-line no-param-reassign
	
	        context = _ref[0];
	        triggerOnInit = _ref[1];
	    }
	
	    // call callback immediatelly if triggerOnInit is true
	    for (var _target2 = names, _index = 0, name, _l2 = _target2.length; name = _target2[_index], _index < _l2; _index++) {
	        var delegatedEventParts = name.split('@');
	
	        if (delegatedEventParts.length > 1) {
	            // if @ exists in event name then this is delegated event
	            var path = delegatedEventParts[0];
	            var delegatedName = delegatedEventParts[1];
	
	            delegateListener(object, path, delegatedName, callback, context);
	        } else {
	            // if not, this is simple event
	            addListener(object, name, callback, context);
	        }
	    }
	
	    if (triggerOnInit === true) {
	        callback.call(context || object, { triggerOnInit: triggerOnInit });
	    }
	
	    return object;
	}

/***/ },
/* 43 */
/***/ function(module, exports) {

	"use strict";
	
	// allows to split by spaces not inclusing ones inside of brackers
	
	module.exports = /\s+(?![^(]*\))/g;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var on = __webpack_require__(42);
	
	var checkObjectType = __webpack_require__(5);
	
	var debounce = __webpack_require__(7);
	
	// adds debounced event listener
	module.exports = onDebounce;
	function onDebounce(object, names, givenCallback, givenDelay, triggerOnInit, context) {
	    if (_typeof(this) === 'object' && this.isMatreshka) {
	        // when context is Matreshka instance, use this as an object and shift other args
	        /* eslint-disable no-param-reassign */
	        context = triggerOnInit;
	        triggerOnInit = givenDelay;
	        givenDelay = givenCallback;
	        givenCallback = names;
	        names = object;
	        object = this;
	        /* eslint-enable no-param-reassign */
	    } else {
	        // throw error when object type is wrong
	        checkObjectType(object, 'onDebounce');
	    }
	
	    var isNamesVarArray = names instanceof Array;
	
	    // allow to pass name-handler object
	    if (names && (typeof names === 'undefined' ? 'undefined' : _typeof(names)) === 'object' && !isNamesVarArray) {
	        for (var _target = names, _keys = Object.keys(_target), _i = 0, namesObjName, namesObjCallback, _l = _keys.length; (namesObjName = _keys[_i], namesObjCallback = _target[namesObjName]), _i < _l; _i++) {
	            onDebounce(object, namesObjName, namesObjCallback, givenCallback, givenDelay, triggerOnInit);
	        }
	
	        return object;
	    }
	
	    var delay = typeof givenDelay === 'number' ? givenDelay : 0;
	
	    var callback = debounce(givenCallback, delay);
	
	    // allow to remove event listener py passing original callback to "off"
	    callback._callback = givenCallback;
	
	    return on(object, names, callback, triggerOnInit, context);
	}

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var domEventReg = __webpack_require__(15);
	
	var checkObjectType = __webpack_require__(5);
	
	var matreshkaError = __webpack_require__(6);
	
	var splitBySpaceReg = __webpack_require__(43);
	
	var defs = __webpack_require__(4);
	
	var triggerOne = __webpack_require__(11);
	
	var triggerDomEvent = __webpack_require__(46);
	
	// triggers an event
	module.exports = trigger;
	function trigger() {
	    var object = void 0;
	    var givenNames = void 0;
	    var triggerArgs = void 0;
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	    }
	
	    if (_typeof(this) === 'object' && this.isMatreshka) {
	        givenNames = args[0];
	        // when context is Matreshka instance, use this as an object and shift other args
	
	        triggerArgs = args.slice(1);
	
	        object = this;
	    } else {
	        // throw error when object type is wrong
	        object = args[0];
	        givenNames = args[1];
	        triggerArgs = args.slice(2);
	        checkObjectType(object, 'trigger');
	    }
	    var names = void 0;
	
	    // allow to use strings only as event name
	    if (typeof givenNames === 'string') {
	        names = givenNames.split(splitBySpaceReg);
	    } else {
	        throw matreshkaError('trigger:names_type', { names: givenNames });
	    }
	
	    var def = defs.get(object);
	
	    // if no definition do nothing
	    if (!def) {
	        return object;
	    }
	
	    var allEvents = def.events;
	
	    if (!allEvents) {
	        return object;
	    }
	
	    for (var _target = names, _index = 0, name, _l = _target.length; name = _target[_index], _index < _l; _index++) {
	        var domEvtExecResult = domEventReg.exec(name);
	
	        if (domEvtExecResult) {
	            // if EVT::KEY(SELECTOR) ia passed as event name then trigger DOM event
	            var eventName = domEvtExecResult[1];
	            var _domEvtExecResult$ = domEvtExecResult[2];
	            var key = _domEvtExecResult$ === undefined ? 'sandbox' : _domEvtExecResult$;
	            var selector = domEvtExecResult[3];
	
	            triggerDomEvent(object, key, eventName, selector, triggerArgs);
	        } else {
	            // trigger ordinary event
	            triggerOne(object, name, triggerArgs);
	        }
	    }
	
	    return object;
	}

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var triggerOneDOMEvent = __webpack_require__(47);
	
	var defs = __webpack_require__(4);
	
	// triggers DOM event on bound nodes
	module.exports = triggerDOMEvent;
	function triggerDOMEvent(object, key, eventName, selector, triggerArgs) {
	    var def = defs.get(object);
	
	    if (!def) {
	        return;
	    }
	
	    var props = def.props;
	
	    var propDef = props[key];
	
	    if (!propDef) {
	        return;
	    }
	
	    var bindings = propDef.bindings;
	
	    if (!bindings) {
	        return;
	    }
	
	    for (var _target2 = bindings, _index2 = 0, _ref, _l2 = _target2.length; _ref = _target2[_index2], _index2 < _l2; _index2++) {
	        var node = _ref.node;
	
	        if (selector) {
	            // if selector is given trigger an event on all node descendants
	            var descendants = node.querySelectorAll(selector);
	
	            for (var _target = descendants, _index = 0, descendant, _l = _target.length; descendant = _target[_index], _index < _l; _index++) {
	                triggerOneDOMEvent({
	                    node: descendant,
	                    eventName: eventName,
	                    triggerArgs: triggerArgs
	                });
	            }
	        } else {
	            // trigger an event for single node
	            triggerOneDOMEvent({
	                node: node,
	                eventName: eventName,
	                triggerArgs: triggerArgs
	            });
	        }
	    }
	
	    return;
	}

/***/ },
/* 47 */
/***/ function(module, exports) {

	'use strict';
	
	// triggers given DOM event on given node
	
	module.exports = triggerOneDOMEvent;
	function triggerOneDOMEvent(_ref) {
	    var node = _ref.node;
	    var eventName = _ref.eventName;
	    var triggerArgs = _ref.triggerArgs;
	    var _window = window;
	    var document = _window.document;
	    var Event = _window.Event;
	
	    var event = void 0;
	
	    // polyfill for older browsers
	    if (document.createEvent) {
	        /* istanbul ignore next */
	        event = document.createEvent('Event');
	        event.initEvent(eventName, true, true);
	    } else if (typeof Event !== 'undefined') {
	        event = new Event(eventName, {
	            bubbles: true,
	            cancelable: true
	        });
	    }
	
	    // matreshkaTriggerArgs will be used in a handler created by addDOMListener
	    event.matreshkaTriggerArgs = triggerArgs;
	
	    node.dispatchEvent(event);
	}

/***/ }
/******/ ])
});
;if(typeof define === 'function' && define.amd){
                                define('matreshka/foo', ['matreshka'], function(Matreshka){
            return Matreshka.foo;
        })
                            }
//# sourceMappingURL=matreshka-router.min.js.map